(* GENERATED BY scripts/generate-entrypoints.rb SCRIPT, DO NOT EDIT BY HAND! *)

(* open CheckerTypes *)
(* open Checker *)
(* open Kit *)
(* open Lqt *)
(* open Tok *)
(* open LiquidationAuctionTypes *)
(* open LiquidationAuctionPrimitiveTypes *)
(* open Ctok *)
(* open Fa2Interface *)
(* open Error *)

type lazy_params =
  | Touch of unit
  | Create_burrow of (nat * key_hash option * tok)
  | Deposit_collateral of (nat * tok)
  | Withdraw_collateral of (nat * tok)
  | Mint_kit of (nat * kit)
  | Burn_kit of (nat * kit)
  | Activate_burrow of (nat * tok)
  | Deactivate_burrow of (nat * address)
  | Mark_for_liquidation of burrow_id
  | Touch_liquidation_slices of leaf_ptr list
  | Cancel_liquidation_slice of leaf_ptr
  | Touch_burrow of burrow_id
  | Set_burrow_delegate of (nat * key_hash option)
  | Buy_kit of (ctok * kit * timestamp)
  | Sell_kit of (kit * ctok * timestamp)
  | Add_liquidity of (ctok * kit * lqt * timestamp)
  | Remove_liquidity of (lqt * ctok * kit * timestamp)
  | Liquidation_auction_place_bid of (liquidation_auction_id * kit)
  | Liquidation_auction_claim_win of liquidation_auction_id
  | Receive_price of (nat * nat)
  | Receive_ctez_marginal_price of (nat * nat)
  | Update_operators of fa2_update_operator list

[@inline] let lazy_id_touch = (0)
[@inline] let lazy_id_create_burrow = (1)
[@inline] let lazy_id_deposit_collateral = (2)
[@inline] let lazy_id_withdraw_collateral = (3)
[@inline] let lazy_id_mint_kit = (4)
[@inline] let lazy_id_burn_kit = (5)
[@inline] let lazy_id_activate_burrow = (6)
[@inline] let lazy_id_deactivate_burrow = (7)
[@inline] let lazy_id_mark_for_liquidation = (8)
[@inline] let lazy_id_touch_liquidation_slices = (9)
[@inline] let lazy_id_cancel_liquidation_slice = (10)
[@inline] let lazy_id_touch_burrow = (11)
[@inline] let lazy_id_set_burrow_delegate = (12)
[@inline] let lazy_id_buy_kit = (13)
[@inline] let lazy_id_sell_kit = (14)
[@inline] let lazy_id_add_liquidity = (15)
[@inline] let lazy_id_remove_liquidity = (16)
[@inline] let lazy_id_liquidation_auction_place_bid = (17)
[@inline] let lazy_id_liquidation_auction_claim_win = (18)
[@inline] let lazy_id_receive_price = (19)
[@inline] let lazy_id_receive_ctez_marginal_price = (20)
[@inline] let lazy_id_update_operators = (21)

type lazy_function = checker * bytes -> operation list * checker

let lazyParamsToLazyFunctionId (p: lazy_params) : lazy_function_id * bytes =
  match p with
  | Touch a -> (lazy_id_touch, Bytes.pack a)
  | Create_burrow a -> (lazy_id_create_burrow, Bytes.pack a)
  | Deposit_collateral a -> (lazy_id_deposit_collateral, Bytes.pack a)
  | Withdraw_collateral a -> (lazy_id_withdraw_collateral, Bytes.pack a)
  | Mint_kit a -> (lazy_id_mint_kit, Bytes.pack a)
  | Burn_kit a -> (lazy_id_burn_kit, Bytes.pack a)
  | Activate_burrow a -> (lazy_id_activate_burrow, Bytes.pack a)
  | Deactivate_burrow a -> (lazy_id_deactivate_burrow, Bytes.pack a)
  | Mark_for_liquidation a -> (lazy_id_mark_for_liquidation, Bytes.pack a)
  | Touch_liquidation_slices a -> (lazy_id_touch_liquidation_slices, Bytes.pack a)
  | Cancel_liquidation_slice a -> (lazy_id_cancel_liquidation_slice, Bytes.pack a)
  | Touch_burrow a -> (lazy_id_touch_burrow, Bytes.pack a)
  | Set_burrow_delegate a -> (lazy_id_set_burrow_delegate, Bytes.pack a)
  | Buy_kit a -> (lazy_id_buy_kit, Bytes.pack a)
  | Sell_kit a -> (lazy_id_sell_kit, Bytes.pack a)
  | Add_liquidity a -> (lazy_id_add_liquidity, Bytes.pack a)
  | Remove_liquidity a -> (lazy_id_remove_liquidity, Bytes.pack a)
  | Liquidation_auction_place_bid a -> (lazy_id_liquidation_auction_place_bid, Bytes.pack a)
  | Liquidation_auction_claim_win a -> (lazy_id_liquidation_auction_claim_win, Bytes.pack a)
  | Receive_price a -> (lazy_id_receive_price, Bytes.pack a)
  | Receive_ctez_marginal_price a -> (lazy_id_receive_ctez_marginal_price, Bytes.pack a)
  | Update_operators a -> (lazy_id_update_operators, Bytes.pack a)

(* BEGIN_LIGO *)
   let lazy_fun_touch (checker, params: checker * bytes): operation list * checker =
   match (Bytes.unpack params: unit option) with
   | Some p -> entrypoint_touch (checker, p)
   | None -> (failwith error_UnexpectedParams : operation list * checker)
   (* END_LIGO *)

(* BEGIN_LIGO *)
   let lazy_fun_create_burrow (checker, params: checker * bytes): operation list * checker =
   match (Bytes.unpack params: (nat * key_hash option * tok) option) with
   | Some p -> entrypoint_create_burrow (checker, p)
   | None -> (failwith error_UnexpectedParams : operation list * checker)
   (* END_LIGO *)

(* BEGIN_LIGO *)
   let lazy_fun_deposit_collateral (checker, params: checker * bytes): operation list * checker =
   match (Bytes.unpack params: (nat * tok) option) with
   | Some p -> entrypoint_deposit_collateral (checker, p)
   | None -> (failwith error_UnexpectedParams : operation list * checker)
   (* END_LIGO *)

(* BEGIN_LIGO *)
   let lazy_fun_withdraw_collateral (checker, params: checker * bytes): operation list * checker =
   match (Bytes.unpack params: (nat * tok) option) with
   | Some p -> entrypoint_withdraw_collateral (checker, p)
   | None -> (failwith error_UnexpectedParams : operation list * checker)
   (* END_LIGO *)

(* BEGIN_LIGO *)
   let lazy_fun_mint_kit (checker, params: checker * bytes): operation list * checker =
   match (Bytes.unpack params: (nat * kit) option) with
   | Some p -> entrypoint_mint_kit (checker, p)
   | None -> (failwith error_UnexpectedParams : operation list * checker)
   (* END_LIGO *)

(* BEGIN_LIGO *)
   let lazy_fun_burn_kit (checker, params: checker * bytes): operation list * checker =
   match (Bytes.unpack params: (nat * kit) option) with
   | Some p -> entrypoint_burn_kit (checker, p)
   | None -> (failwith error_UnexpectedParams : operation list * checker)
   (* END_LIGO *)

(* BEGIN_LIGO *)
   let lazy_fun_activate_burrow (checker, params: checker * bytes): operation list * checker =
   match (Bytes.unpack params: (nat * tok) option) with
   | Some p -> entrypoint_activate_burrow (checker, p)
   | None -> (failwith error_UnexpectedParams : operation list * checker)
   (* END_LIGO *)

(* BEGIN_LIGO *)
   let lazy_fun_deactivate_burrow (checker, params: checker * bytes): operation list * checker =
   match (Bytes.unpack params: (nat * address) option) with
   | Some p -> entrypoint_deactivate_burrow (checker, p)
   | None -> (failwith error_UnexpectedParams : operation list * checker)
   (* END_LIGO *)

(* BEGIN_LIGO *)
   let lazy_fun_mark_for_liquidation (checker, params: checker * bytes): operation list * checker =
   match (Bytes.unpack params: burrow_id option) with
   | Some p -> entrypoint_mark_for_liquidation (checker, p)
   | None -> (failwith error_UnexpectedParams : operation list * checker)
   (* END_LIGO *)

(* BEGIN_LIGO *)
   let lazy_fun_touch_liquidation_slices (checker, params: checker * bytes): operation list * checker =
   match (Bytes.unpack params: leaf_ptr list option) with
   | Some p -> entrypoint_touch_liquidation_slices (checker, p)
   | None -> (failwith error_UnexpectedParams : operation list * checker)
   (* END_LIGO *)

(* BEGIN_LIGO *)
   let lazy_fun_cancel_liquidation_slice (checker, params: checker * bytes): operation list * checker =
   match (Bytes.unpack params: leaf_ptr option) with
   | Some p -> entrypoint_cancel_liquidation_slice (checker, p)
   | None -> (failwith error_UnexpectedParams : operation list * checker)
   (* END_LIGO *)

(* BEGIN_LIGO *)
   let lazy_fun_touch_burrow (checker, params: checker * bytes): operation list * checker =
   match (Bytes.unpack params: burrow_id option) with
   | Some p -> entrypoint_touch_burrow (checker, p)
   | None -> (failwith error_UnexpectedParams : operation list * checker)
   (* END_LIGO *)

(* BEGIN_LIGO *)
   let lazy_fun_set_burrow_delegate (checker, params: checker * bytes): operation list * checker =
   match (Bytes.unpack params: (nat * key_hash option) option) with
   | Some p -> entrypoint_set_burrow_delegate (checker, p)
   | None -> (failwith error_UnexpectedParams : operation list * checker)
   (* END_LIGO *)

(* BEGIN_LIGO *)
   let lazy_fun_buy_kit (checker, params: checker * bytes): operation list * checker =
   match (Bytes.unpack params: (ctok * kit * timestamp) option) with
   | Some p -> entrypoint_buy_kit (checker, p)
   | None -> (failwith error_UnexpectedParams : operation list * checker)
   (* END_LIGO *)

(* BEGIN_LIGO *)
   let lazy_fun_sell_kit (checker, params: checker * bytes): operation list * checker =
   match (Bytes.unpack params: (kit * ctok * timestamp) option) with
   | Some p -> entrypoint_sell_kit (checker, p)
   | None -> (failwith error_UnexpectedParams : operation list * checker)
   (* END_LIGO *)

(* BEGIN_LIGO *)
   let lazy_fun_add_liquidity (checker, params: checker * bytes): operation list * checker =
   match (Bytes.unpack params: (ctok * kit * lqt * timestamp) option) with
   | Some p -> entrypoint_add_liquidity (checker, p)
   | None -> (failwith error_UnexpectedParams : operation list * checker)
   (* END_LIGO *)

(* BEGIN_LIGO *)
   let lazy_fun_remove_liquidity (checker, params: checker * bytes): operation list * checker =
   match (Bytes.unpack params: (lqt * ctok * kit * timestamp) option) with
   | Some p -> entrypoint_remove_liquidity (checker, p)
   | None -> (failwith error_UnexpectedParams : operation list * checker)
   (* END_LIGO *)

(* BEGIN_LIGO *)
   let lazy_fun_liquidation_auction_place_bid (checker, params: checker * bytes): operation list * checker =
   match (Bytes.unpack params: (liquidation_auction_id * kit) option) with
   | Some p -> entrypoint_liquidation_auction_place_bid (checker, p)
   | None -> (failwith error_UnexpectedParams : operation list * checker)
   (* END_LIGO *)

(* BEGIN_LIGO *)
   let lazy_fun_liquidation_auction_claim_win (checker, params: checker * bytes): operation list * checker =
   match (Bytes.unpack params: liquidation_auction_id option) with
   | Some p -> entrypoint_liquidation_auction_claim_win (checker, p)
   | None -> (failwith error_UnexpectedParams : operation list * checker)
   (* END_LIGO *)

(* BEGIN_LIGO *)
   let lazy_fun_receive_price (checker, params: checker * bytes): operation list * checker =
   match (Bytes.unpack params: (nat * nat) option) with
   | Some p -> entrypoint_receive_price (checker, p)
   | None -> (failwith error_UnexpectedParams : operation list * checker)
   (* END_LIGO *)

(* BEGIN_LIGO *)
   let lazy_fun_receive_ctez_marginal_price (checker, params: checker * bytes): operation list * checker =
   match (Bytes.unpack params: (nat * nat) option) with
   | Some p -> entrypoint_receive_ctez_marginal_price (checker, p)
   | None -> (failwith error_UnexpectedParams : operation list * checker)
   (* END_LIGO *)

(* BEGIN_LIGO *)
   let lazy_fun_update_operators (checker, params: checker * bytes): operation list * checker =
   match (Bytes.unpack params: fa2_update_operator list option) with
   | Some p -> entrypoint_update_operators (checker, p)
   | None -> (failwith error_UnexpectedParams : operation list * checker)
   (* END_LIGO *)


let wrapper_view_buy_kit_min_kit_expected (param, wrapper: ctok * wrapper): kit =
  match wrapper.deployment_state with
  | Sealed checker -> view_buy_kit_min_kit_expected (param, checker)
  | Unsealed _ -> (failwith error_ContractNotDeployed: kit)

let wrapper_view_sell_kit_min_ctok_expected (param, wrapper: kit * wrapper): ctok =
  match wrapper.deployment_state with
  | Sealed checker -> view_sell_kit_min_ctok_expected (param, checker)
  | Unsealed _ -> (failwith error_ContractNotDeployed: ctok)

let wrapper_view_add_liquidity_max_kit_deposited (param, wrapper: ctok * wrapper): kit =
  match wrapper.deployment_state with
  | Sealed checker -> view_add_liquidity_max_kit_deposited (param, checker)
  | Unsealed _ -> (failwith error_ContractNotDeployed: kit)

let wrapper_view_add_liquidity_min_lqt_minted (param, wrapper: ctok * wrapper): lqt =
  match wrapper.deployment_state with
  | Sealed checker -> view_add_liquidity_min_lqt_minted (param, checker)
  | Unsealed _ -> (failwith error_ContractNotDeployed: lqt)

let wrapper_view_remove_liquidity_min_ctok_withdrawn (param, wrapper: lqt * wrapper): ctok =
  match wrapper.deployment_state with
  | Sealed checker -> view_remove_liquidity_min_ctok_withdrawn (param, checker)
  | Unsealed _ -> (failwith error_ContractNotDeployed: ctok)

let wrapper_view_remove_liquidity_min_kit_withdrawn (param, wrapper: lqt * wrapper): kit =
  match wrapper.deployment_state with
  | Sealed checker -> view_remove_liquidity_min_kit_withdrawn (param, checker)
  | Unsealed _ -> (failwith error_ContractNotDeployed: kit)

let wrapper_view_current_liquidation_auction_details (param, wrapper: unit * wrapper): view_current_liquidation_auction_details_result =
  match wrapper.deployment_state with
  | Sealed checker -> view_current_liquidation_auction_details (param, checker)
  | Unsealed _ -> (failwith error_ContractNotDeployed: view_current_liquidation_auction_details_result)

let wrapper_view_burrow_max_mintable_kit (param, wrapper: burrow_id * wrapper): kit =
  match wrapper.deployment_state with
  | Sealed checker -> view_burrow_max_mintable_kit (param, checker)
  | Unsealed _ -> (failwith error_ContractNotDeployed: kit)

let wrapper_view_is_burrow_overburrowed (param, wrapper: burrow_id * wrapper): bool =
  match wrapper.deployment_state with
  | Sealed checker -> view_is_burrow_overburrowed (param, checker)
  | Unsealed _ -> (failwith error_ContractNotDeployed: bool)

let wrapper_view_is_burrow_liquidatable (param, wrapper: burrow_id * wrapper): bool =
  match wrapper.deployment_state with
  | Sealed checker -> view_is_burrow_liquidatable (param, checker)
  | Unsealed _ -> (failwith error_ContractNotDeployed: bool)

let wrapper_view_get_balance (param, wrapper: (address * fa2_token_id) * wrapper): nat =
  match wrapper.deployment_state with
  | Sealed checker -> view_get_balance (param, checker)
  | Unsealed _ -> (failwith error_ContractNotDeployed: nat)

let wrapper_view_total_supply (param, wrapper: fa2_token_id * wrapper): nat =
  match wrapper.deployment_state with
  | Sealed checker -> view_total_supply (param, checker)
  | Unsealed _ -> (failwith error_ContractNotDeployed: nat)

let wrapper_view_all_tokens (param, wrapper: unit * wrapper): fa2_token_id list =
  match wrapper.deployment_state with
  | Sealed checker -> view_all_tokens (param, checker)
  | Unsealed _ -> (failwith error_ContractNotDeployed: fa2_token_id list)

let wrapper_view_is_operator (param, wrapper: (address * (address * fa2_token_id)) * wrapper): bool =
  match wrapper.deployment_state with
  | Sealed checker -> view_is_operator (param, checker)
  | Unsealed _ -> (failwith error_ContractNotDeployed: bool)
